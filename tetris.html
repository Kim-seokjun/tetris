<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>우리 반 테트리스</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #333;
            color: #fff;
            font-family: sans-serif;
        }

        .game-container {
            display: flex;
            gap: 20px;
        }

        #gameCanvas {
            border: 4px solid #fff;
            background-color: #000;
        }

        .info-panel {
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .score-box, .next-box {
            padding: 15px;
            border: 2px solid #fff;
            background-color: #111;
            text-align: center;
        }

        #nextCanvas {
            border: 2px solid #666;
            background-color: #000;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div class="game-container">
    <canvas id="gameCanvas" width="300" height="600"></canvas>

    <div class="info-panel">
        <div class="score-box">
            <h2>점수</h2>
            <div id="scoreDisplay">0</div>
        </div>

        <div class="next-box">
            <h3>다음 블록</h3>
            <canvas id="nextCanvas" width="120" height="120"></canvas>
        </div>
        <p>조작법: ← → ↓ (이동), ↑ (회전)</p>
    </div>
</div>

<script>
    // --- 설정 ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30; // 30px
    const BASE_DROP_INTERVAL = 1000; // 1000ms (1초)
    const SPEED_INCREASE_INTERVAL = 30 * 1000; // 30초마다
    const SPEED_MULTIPLIER = 0.8; // 속도 20% 증가 (간격 80%로 단축)

    // Canvas 설정
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const scoreDisplay = document.getElementById('scoreDisplay');

    // 캔버스 크기 조정
    canvas.width = COLS * BLOCK_SIZE;
    canvas.height = ROWS * BLOCK_SIZE;
    nextCanvas.width = 4 * BLOCK_SIZE;
    nextCanvas.height = 4 * BLOCK_SIZE;

    // --- 테트로미노 모양 정의 (색상 포함) ---
    const TETROMINOES = [
        { shape: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: 'cyan' }, // I
        { shape: [[2,2], [2,2]], color: 'yellow' }, // O
        { shape: [[0,3,0], [3,3,3], [0,0,0]], color: 'purple' }, // T
        { shape: [[0,4,4], [4,4,0], [0,0,0]], color: 'green' }, // S
        { shape: [[5,5,0], [0,5,5], [0,0,0]], color: 'red' }, // Z
        { shape: [[6,0,0], [6,6,6], [0,0,0]], color: 'blue' }, // J
        { shape: [[0,0,7], [7,7,7], [0,0,0]], color: 'orange' } // L
    ];

    // --- 게임 상태 변수 ---
    let grid = createEmptyGrid();
    let currentPiece;
    let nextPiece;
    let score = 0;
    let dropInterval = BASE_DROP_INTERVAL;
    let lastTime = 0;
    let lastLevelTime = Date.now();
    let gameOver = false;

    // --- 핵심 함수 ---

    function createEmptyGrid() {
        // 게임 보드 (20x10) 생성, 0은 빈 공간
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function getRandomPiece() {
        const type = TETROMINOES[Math.floor(Math.random() * TETROMINOES.length)];
        return {
            shape: type.shape,
            color: type.color,
            x: Math.floor(COLS / 2) - Math.floor(type.shape[0].length / 2),
            y: 0
        };
    }

    function spawnPiece() {
        currentPiece = nextPiece || getRandomPiece();
        nextPiece = getRandomPiece();

        // 게임 오버 체크
        if (!isValidMove(currentPiece, 0, 0)) {
            gameOver = true;
            alert(`게임 오버! 최종 점수: ${score}`);
        }
    }

    function isValidMove(piece, dx, dy, rotation) {
        const shape = rotation ? rotate(piece.shape) : piece.shape;

        for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                    const newX = piece.x + x + dx;
                    const newY = piece.y + y + dy;

                    // 경계 및 충돌 검사
                    if (newX < 0 || newX >= COLS || newY >= ROWS || (newY >= 0 && grid[newY][newX])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    function rotate(matrix) {
        // 블록을 시계 방향으로 90도 회전
        const N = matrix.length;
        const newMatrix = Array.from({ length: N }, () => Array(N).fill(0));
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                newMatrix[j][N - 1 - i] = matrix[i][j];
            }
        }
        return newMatrix;
    }

    function lockPiece() {
        // 블록을 그리드에 고정
        for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
                if (currentPiece.shape[y][x]) {
                    grid[currentPiece.y + y][currentPiece.x + x] = currentPiece.color;
                }
            }
        }
        clearLines();
        spawnPiece();
    }

    function clearLines() {
        let linesCleared = 0;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (grid[y].every(cell => cell !== 0)) {
                // 한 줄이 모두 채워졌다면
                grid.splice(y, 1); // 해당 줄 삭제
                grid.unshift(Array(COLS).fill(0)); // 맨 위에 새로운 빈 줄 추가
                linesCleared++;
                y++; // 줄을 다시 검사해야 하므로 y 증가
            }
        }

        if (linesCleared > 0) {
            // 점수 계산 (테트리스 공식에 따라 1줄:100, 2줄:300, 3줄:500, 4줄:800 등)
            const points = [0, 100, 300, 500, 800];
            score += points[linesCleared];
            updateScoreDisplay();
        }
    }
    
    function updateScoreDisplay() {
        scoreDisplay.textContent = score;
    }

    function updateSpeed() {
        const currentTime = Date.now();
        if (currentTime - lastLevelTime >= SPEED_INCREASE_INTERVAL) {
            // 30초가 지났다면 속도 증가
            dropInterval = Math.max(100, dropInterval * SPEED_MULTIPLIER); // 최소 100ms
            lastLevelTime = currentTime;
            console.log(`속도 증가! 새로운 간격: ${dropInterval}ms`);
        }
    }

    // --- 드로잉 함수 ---

    function drawBlock(x, y, color, ctx, isGrid = true) {
        ctx.fillStyle = color;
        const drawX = isGrid ? x * BLOCK_SIZE : x;
        const drawY = isGrid ? y * BLOCK_SIZE : y;

        // 실제 블록
        ctx.fillRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
        // 블록 경계선 (선택 사항)
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(drawX, drawY, BLOCK_SIZE, BLOCK_SIZE);
    }

    function draw() {
        if (gameOver) return;

        // 메인 캔버스 초기화
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 1. 고정된 블록 그리기
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (grid[y][x]) {
                    drawBlock(x, y, grid[y][x], ctx);
                }
            }
        }

        // 2. 현재 떨어지는 블록 그리기
        if (currentPiece) {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length